import React, { useState, useEffect } from 'react';

interface PlaceholderField {
  path: string;
  type: string;
  label: string;
}

interface PlaceholderVariable {
  variable_name: string;
  description: string;
  is_array: boolean;
  requires_runtime_index?: boolean;
  usage_patterns?: Array<{
    pattern: string;
    description: string;
  }>;
  fields: PlaceholderField[];
}

interface PlaceholderSelectorProps {
  onPlaceholderSelect: (placeholder: string) => void;
  className?: string;
}

/**
 * Get a human-readable description for a variable
 */
const getVariableDescription = (varName: string): string => {
  switch (varName) {
    case 'CONVERSATION_MEMORY':
      return 'Memory data from the current conversation';
    case 'USER_PERSONA':
      return 'Aggregated user persona across all conversations';
    case 'PREVIOUS_CONVERSATIONS_MEMORY':
      return 'Array of memories from previous conversations';
    default:
      return 'Placeholder variable';
  }
};

/**
 * Placeholder Selector Component
 *
 * Allows users to build placeholder strings for prompt templates using cascading dropdowns.
 * Loads available fields from a static JSON file generated by the parser.
 *
 * Features:
 * - Cascading dropdowns (variable → field → nested field)
 * - Live preview of partial placeholder strings
 * - Special handling for array variables (PREVIOUS_CONVERSATIONS_MEMORY)
 * - Support for nested JSON access (e.g., {{CONVERSATION_MEMORY__curiosity_boosters__comment}})
 */
export const PlaceholderSelector: React.FC<PlaceholderSelectorProps> = ({
  onPlaceholderSelect,
  className = ''
}) => {
  const [variables, setVariables] = useState<Record<string, PlaceholderVariable>>({});
  const [selectedVariable, setSelectedVariable] = useState<string>('');
  const [selectedPath, setSelectedPath] = useState<string[]>([]);
  const [arrayIndex, setArrayIndex] = useState<string>('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string>('');

  // Load metadata from static JSON file on mount
  useEffect(() => {
    const loadMetadata = async () => {
      setLoading(true);
      setError('');
      try {
        const response = await fetch('/placeholder_metadata.json');

        if (!response.ok) {
          throw new Error('Failed to load placeholder metadata');
        }

        const metadata = await response.json();

        // Transform the metadata to match the expected format
        const transformedVariables: Record<string, PlaceholderVariable> = {};

        for (const [varName, varData] of Object.entries(metadata)) {
          const data = varData as any;
          transformedVariables[varName] = {
            variable_name: varName,
            description: getVariableDescription(varName),
            is_array: data.is_array || false,
            requires_runtime_index: data.requires_runtime_index || false,
            usage_patterns: data.usage_patterns,
            fields: data.fields || []
          };
        }

        setVariables(transformedVariables);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
        setVariables({});
      } finally {
        setLoading(false);
      }
    };

    loadMetadata();
  }, []);

  // Reset selections when variable changes
  useEffect(() => {
    setSelectedPath([]);
    setArrayIndex('');
  }, [selectedVariable]);

  // Build the current placeholder string
  const buildPlaceholder = (): string => {
    if (!selectedVariable) return '';

    const parts = [selectedVariable];
    const varInfo = variables[selectedVariable];

    // Handle array variables with index
    if (varInfo?.is_array && varInfo?.requires_runtime_index && arrayIndex) {
      parts.push(arrayIndex);
    }

    // Add selected path
    parts.push(...selectedPath);

    return `{{${parts.join('__')}}}`;
  };

  const currentPlaceholder = buildPlaceholder();

  // Get available fields for current selection
  const getAvailableFields = (): PlaceholderField[] => {
    if (!selectedVariable) return [];

    const varInfo = variables[selectedVariable];
    if (!varInfo) return [];

    // If no path selected, show top-level fields
    if (selectedPath.length === 0) {
      return varInfo.fields.filter(f => !f.path.includes('__'));
    }

    // Otherwise, show children of the current path
    const currentFullPath = selectedPath.join('__');
    return varInfo.fields.filter(f => {
      // Must start with current path
      if (!f.path.startsWith(currentFullPath + '__')) return false;

      // Must be a direct child (not grandchild)
      const remainder = f.path.slice(currentFullPath.length + 2); // +2 for '__'
      return !remainder.includes('__');
    });
  };

  const availableFields = getAvailableFields();

  const handleVariableSelect = (varName: string) => {
    setSelectedVariable(varName);
  };

  const handleFieldSelect = (field: PlaceholderField) => {
    // Extract just the new part of the path
    if (selectedPath.length === 0) {
      setSelectedPath([field.path]);
    } else {
      const currentFullPath = selectedPath.join('__');
      const newPart = field.path.slice(currentFullPath.length + 2);
      setSelectedPath([...selectedPath, newPart]);
    }
  };

  const handleBack = () => {
    setSelectedPath(prev => prev.slice(0, -1));
  };

  const handleUseThis = () => {
    if (currentPlaceholder) {
      onPlaceholderSelect(currentPlaceholder);
    }
  };

  const handleReset = () => {
    setSelectedVariable('');
    setSelectedPath([]);
    setArrayIndex('');
  };

  if (loading) {
    return <div className={className}>Loading placeholder metadata...</div>;
  }

  if (error) {
    return (
      <div className={`${className} text-red-600`}>
        <p>Error: {error}</p>
        <p className="text-sm mt-1">
          Make sure the prompt has a valid JSON example in its text.
        </p>
      </div>
    );
  }

  const variableList = Object.keys(variables);

  if (variableList.length === 0) {
    return (
      <div className={className}>
        <p className="text-gray-500">
          No placeholder variables available for this prompt.
        </p>
        <p className="text-xs text-gray-400 mt-1">
          The prompt text must contain a JSON example for placeholder parsing.
        </p>
      </div>
    );
  }

  return (
    <div className={`${className} space-y-4`}>
      <div>
        <h4 className="text-sm font-medium mb-2">Build Placeholder</h4>

        {/* Variable Selection */}
        <div className="mb-3">
          <label className="block text-xs font-medium text-gray-700 mb-1">
            1. Select Variable
          </label>
          <select
            value={selectedVariable}
            onChange={(e) => handleVariableSelect(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            <option value="">-- Choose variable --</option>
            {variableList.map(varName => (
              <option key={varName} value={varName}>
                {varName} ({variables[varName].description})
              </option>
            ))}
          </select>
        </div>

        {/* Array Index Input (for PREVIOUS_CONVERSATIONS_MEMORY) */}
        {selectedVariable && variables[selectedVariable]?.requires_runtime_index && (
          <div className="mb-3 pl-4">
            <label className="block text-xs font-medium text-gray-700 mb-1">
              2a. Array Index (optional)
            </label>
            <input
              type="text"
              value={arrayIndex}
              onChange={(e) => setArrayIndex(e.target.value)}
              placeholder="0, 1, 2... (leave empty for all)"
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
            <p className="text-xs text-gray-500 mt-1">
              Leave empty to get the field from ALL conversations
            </p>
          </div>
        )}

        {/* Field Selection */}
        {selectedVariable && (
          <div className="mb-3 pl-4">
            <label className="block text-xs font-medium text-gray-700 mb-1">
              {variables[selectedVariable]?.requires_runtime_index ? '2b' : '2'}. Select Field
              {selectedPath.length > 0 && (
                <button
                  onClick={handleBack}
                  className="ml-2 text-xs text-blue-600 hover:text-blue-800"
                >
                  ← Back
                </button>
              )}
            </label>

            {availableFields.length > 0 ? (
              <select
                value=""
                onChange={(e) => {
                  const field = availableFields.find(f => f.path === e.target.value);
                  if (field) handleFieldSelect(field);
                }}
                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                <option value="">
                  {selectedPath.length === 0
                    ? '-- Choose field --'
                    : '-- Choose nested field or stop here --'}
                </option>
                {availableFields.map(field => (
                  <option key={field.path} value={field.path}>
                    {field.label} ({field.type})
                  </option>
                ))}
              </select>
            ) : (
              <p className="text-xs text-gray-500">
                No more nested fields available (leaf node reached)
              </p>
            )}
          </div>
        )}
      </div>

      {/* Preview */}
      {currentPlaceholder && (
        <div className="border-t pt-3">
          <label className="block text-xs font-medium text-gray-700 mb-1">
            Preview
          </label>
          <div className="bg-gray-50 px-3 py-2 rounded border border-gray-200 font-mono text-sm">
            {currentPlaceholder}
          </div>

          <div className="mt-2 flex gap-2">
            <button
              onClick={handleUseThis}
              className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
              Use This Placeholder
            </button>
            <button
              onClick={handleReset}
              className="px-4 py-2 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400"
            >
              Reset
            </button>
          </div>
        </div>
      )}

      {/* Usage Patterns (for array variables) */}
      {selectedVariable && variables[selectedVariable]?.usage_patterns && (
        <div className="border-t pt-3">
          <label className="block text-xs font-medium text-gray-700 mb-2">
            Usage Patterns
          </label>
          <div className="space-y-2">
            {variables[selectedVariable].usage_patterns!.map((pattern, idx) => (
              <div key={idx} className="text-xs bg-blue-50 p-2 rounded">
                <code className="text-blue-800 font-mono">{pattern.pattern}</code>
                <p className="text-gray-600 mt-1">{pattern.description}</p>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};

export default PlaceholderSelector;
