# Placeholder System Analysis

## Overview
This document analyzes the current state of the placeholder injection system in `Brain/src/utils/prompt_injection.py` and tracks nested JSON access capabilities.

---

## Current Placeholder Types & Capabilities

| Placeholder Type | Regex Pattern | Source Data Schema | Used In Files | Nested Key Support (`__key__subkey`) | Full JSON Injection | Status |
|-----------------|---------------|-------------------|---------------|-------------------------------------|-------------------|---------|
| `{{CONVERSATION_MEMORY}}` | `PLACEHOLDER_REGEX` (line 22) | `ConversationMemoryData` (schemas.py:130-138) | `final_response_generator.py:229-231` | ‚úÖ PARTIALLY SUPPORTED | ‚úÖ YES (when no keys specified) | **INCOMPLETE** |
| `{{USER_PERSONA}}` | `PERSONA_PLACEHOLDER_REGEX` (line 35) | `UserPersonaData` (schemas.py:144-152) | `final_response_generator.py:224-226`<br>`main.py:624,666`<br>`process_query_entrypoint.py:245,253` | ‚ùå NOT SUPPORTED | ‚úÖ YES (full JSON dump, line 214) | **NEEDS WORK** |
| `{{PREVIOUS_CONVERSATIONS_MEMORY}}` | `PREVIOUS_MEMORY_PLACEHOLDER_REGEX` (line 42-44) | List of `ConversationMemoryData` | `main.py:663`<br>`process_query_entrypoint.py:253` | ‚ùå NOT SUPPORTED | ‚úÖ YES (full JSON dump, line 259) | **NEEDS WORK** |

---

## Detailed Analysis

### 1. `{{CONVERSATION_MEMORY}}`

#### Schema (from schemas.py:130-138)
```python
class ConversationMemoryData(BaseModel):
    curiosity_boosters: Dict[str, Any]          # Nested: boosters_attempted[], not_attempted[], comment
    invitation_to_come_back: Dict[str, Any]     # Nested: inviting_to_come_back, category, evidence, comment
    knowledge_journey: Dict[str, Any]           # Nested: initial_knowledge{}, ai_contributions{}, missing_for_holistic_picture{}
    kid_learning_profile: Dict[str, Any]        # Nested: attention_span{}, ability_to_grasp{}, processing_time{}, engagement_patterns{}
```

#### Output Source
- **Generated by**: `memory_generation_prompt.txt` (lines 14-72)
- **Keys derived from**: `ConversationMemoryData.model_fields` (prompt_injection.py:10)

#### Current Implementation
- **Function**: `inject_memory_placeholders()` (line 115-135)
- **Extract function**: `extract_memory_placeholders()` (line 47-61)
- **Rendering**: `render_memory_snippet()` (line 86-112)

#### Nested Key Support Status
- ‚úÖ **Top-level key access**: `{{CONVERSATION_MEMORY__curiosity_boosters}}` - WORKS
- ‚ùì **Nested key access**: `{{CONVERSATION_MEMORY__curiosity_boosters__comment}}` - **UNCLEAR/UNTESTED**
  - Code at line 57 splits by `__` and creates `requested_keys` list
  - But `render_memory_snippet()` only does `memory.get(key)` (line 102) - **does NOT handle nested paths**
  - **VERDICT**: Code accepts nested syntax but **DOES NOT TRAVERSE** nested dicts

#### Gap Identified
The regex extracts nested paths like `curiosity_boosters__comment`, but the rendering function doesn't traverse into nested dictionaries. It only accesses top-level keys.

---

### 2. `{{USER_PERSONA}}`

#### Schema (from schemas.py:144-152)
```python
class UserPersonaData(BaseModel):
    curiosity_boosters: Dict[str, Any]          # Aggregated from all conversations
    invitation_to_come_back: Dict[str, Any]     # Aggregated patterns
    knowledge_journey: Dict[str, Any]           # Aggregated interests
    kid_learning_profile: Dict[str, Any]        # Overall assessment
```

#### Output Source
- **Generated by**: `user_persona_generation_prompt.txt` (lines 12-62)
- **Expected structure** (from prompt lines 13-61):
  ```json
  {
    "curiosity_boosters": {
      "most_effective": [{"category": str, "evidence": str, "frequency": str}],
      "least_effective": [str],
      "comment": str
    },
    "invitation_to_come_back": {
      "preferred_endings": str,
      "return_triggers": str,
      "comment": str
    },
    "knowledge_journey": {
      "primary_interests": {"topic_category_1": str, ...},
      "learning_progression": str,
      "exploration_style": str,
      "missing_opportunities": [str]
    },
    "kid_learning_profile": {
      "attention_span": {"overall_assessment": str, "evidence": str, "comment": str},
      "ability_to_grasp": {...},
      "processing_time": {...},
      "engagement_patterns": {...}
    }
  }
  ```

#### Current Implementation
- **Function**: `inject_persona_placeholders()` (line 183-219)
- **Extract function**: `extract_persona_placeholders()` (line 138-152)
- **Rendering**: `render_persona_snippet()` (line 155-180) - **NEVER CALLED!**

#### Nested Key Support Status
- ‚ùå **No nested key support at all**
- Current behavior: **Full JSON dump only** (line 211-214)
- Extract function exists but is **ignored** - the `requested_keys` are extracted but not used
- Code at line 216: `for token, _ in placeholders:` - the `_` throws away the requested keys!

#### Gap Identified
The function completely ignores any key specifications and always dumps the full JSON. The extraction and rendering infrastructure exists but is not connected.

---

### 3. `{{PREVIOUS_CONVERSATIONS_MEMORY}}`

#### Schema
List of `ConversationMemoryData` objects (same schema as `CONVERSATION_MEMORY`)

#### Output Source
- Retrieved from database/backend (list of previous conversation memories)

#### Current Implementation
- **Function**: `inject_previous_memories_placeholder()` (line 222-265)
- **No key extraction** - always full dump

#### Nested Key Support Status
- ‚ùå **No nested key support at all**
- ‚ùå **No regex group for keys** - regex doesn't even capture key patterns (line 42-44)
- Current behavior: **Full JSON dump of all memories** (lines 252-260)

#### Gap Identified
This placeholder has no infrastructure for selective key access at all. The regex doesn't even have a capture group for keys.

---

## Missing Nested Access Implementation

### Problem
All three placeholders can only access:
1. **Full data** (when no keys specified)
2. **Top-level keys only** (for CONVERSATION_MEMORY)

None of them can traverse nested dictionaries like:
- `{{CONVERSATION_MEMORY__curiosity_boosters__comment}}`
- `{{USER_PERSONA__kid_learning_profile__attention_span__overall_assessment}}`
- `{{PREVIOUS_CONVERSATIONS_MEMORY__curiosity_boosters__boosters_attempted}}`

### Root Cause
The rendering functions (`render_memory_snippet`, `render_persona_snippet`) do simple `dict.get(key)` without path traversal.

**Code location**: `prompt_injection.py:102`
```python
value = memory.get(key)  # Only gets top-level keys!
```

---

## Recommendations for Nested Access

### Option 1: Add Path Traversal Helper
```python
def _get_nested_value(data: Dict[str, Any], key_path: List[str]) -> Any:
    """
    Traverse nested dictionary using key path.
    Example: ['curiosity_boosters', 'comment'] -> data['curiosity_boosters']['comment']
    """
    value = data
    for key in key_path:
        if isinstance(value, dict):
            value = value.get(key)
            if value is None:
                return None
        else:
            return None
    return value
```

Then modify rendering functions to use this instead of `memory.get(key)`.

### Option 2: Use JSONPath or jmespath
Install a library like `jmespath` to handle complex nested queries:
```python
import jmespath
value = jmespath.search('curiosity_boosters.comment', memory)
```

---

## UI/UX Requirements for Prompt Editor

### Data Flow
```
LLM Output ‚Üí schemas.py (defines structure) ‚Üí prompt files (generate the data)
         ‚Üì
    Backend/DB stores data
         ‚Üì
    prompt_injection.py reads schemas ‚Üí UI needs to reflect available keys
```

### Challenge
The schemas use `Dict[str, Any]` which loses type information. The actual structure is defined in:
1. **For CONVERSATION_MEMORY**: `memory_generation_prompt.txt:14-72`
2. **For USER_PERSONA**: `user_persona_generation_prompt.txt:12-62`

### UI Mapping Strategy

#### Approach 1: Static Configuration File
Create `prompt_field_mappings.json`:
```json
{
  "CONVERSATION_MEMORY": {
    "source_prompt": "memory_generation_prompt.txt",
    "schema": "ConversationMemoryData",
    "fields": {
      "curiosity_boosters": {
        "type": "object",
        "nested": {
          "boosters_attempted": {"type": "array"},
          "not_attempted": {"type": "array"},
          "comment": {"type": "string"}
        }
      },
      "invitation_to_come_back": {
        "type": "object",
        "nested": {
          "inviting_to_come_back": {"type": "boolean"},
          "category": {"type": "string"},
          "evidence": {"type": "string"},
          "comment": {"type": "string"}
        }
      },
      "knowledge_journey": {
        "type": "object",
        "nested": {
          "initial_knowledge": {"type": "object"},
          "ai_contributions": {"type": "object"},
          "missing_for_holistic_picture": {"type": "object"}
        }
      },
      "kid_learning_profile": {
        "type": "object",
        "nested": {
          "attention_span": {
            "type": "object",
            "nested": {
              "assessment": {"type": "string"},
              "evidence": {"type": "string"},
              "comment": {"type": "string"}
            }
          },
          "ability_to_grasp": {"type": "object", "nested": {...}},
          "processing_time": {"type": "object", "nested": {...}},
          "engagement_patterns": {"type": "object", "nested": {...}}
        }
      }
    }
  },
  "USER_PERSONA": {
    "source_prompt": "user_persona_generation_prompt.txt",
    "schema": "UserPersonaData",
    "fields": {
      "curiosity_boosters": {
        "type": "object",
        "nested": {
          "most_effective": {"type": "array"},
          "least_effective": {"type": "array"},
          "comment": {"type": "string"}
        }
      },
      "invitation_to_come_back": {...},
      "knowledge_journey": {...},
      "kid_learning_profile": {...}
    }
  },
  "PREVIOUS_CONVERSATIONS_MEMORY": {
    "note": "Same structure as CONVERSATION_MEMORY but as array",
    "is_array": true,
    "item_schema": "ConversationMemoryData"
  }
}
```

#### Approach 2: Parse Prompt Files
Build a tool that parses the prompt output format sections and extracts the JSON structure automatically.

#### Approach 3: Hybrid - Pydantic Schema Enhancement
Enhance the Pydantic schemas with nested models instead of `Dict[str, Any]`:

```python
class CuriosityBoostersData(BaseModel):
    boosters_attempted: List[BoosterAttempted]
    not_attempted: List[str]
    comment: str

class ConversationMemoryData(BaseModel):
    curiosity_boosters: CuriosityBoostersData  # Instead of Dict[str, Any]
    invitation_to_come_back: InvitationToComebackData
    knowledge_journey: KnowledgeJourneyData
    kid_learning_profile: KidLearningProfileData
```

Then use Pydantic's `.schema()` or `.model_json_schema()` to auto-generate UI metadata.

---

## Next Steps

1. **Fix nested traversal** in `render_memory_snippet()` and `render_persona_snippet()`
2. **Hook up key extraction** in `inject_persona_placeholders()` (currently ignored)
3. **Add key extraction** to `inject_previous_memories_placeholder()`
4. **Choose UI mapping approach** and implement
5. **Write tests** for nested access patterns
6. **Update documentation** with examples

---

## Example Use Cases

### Current State (Broken)
```
{{CONVERSATION_MEMORY__curiosity_boosters__comment}}
‚Üí Result: Tries to get key "curiosity_boosters__comment" from top level (fails)
```

### Desired State
```
{{CONVERSATION_MEMORY__curiosity_boosters__comment}}
‚Üí Result: Traverses to memory['curiosity_boosters']['comment']
‚Üí Output: "Kid responds best to playful analogies and real-world examples"

{{USER_PERSONA__kid_learning_profile__attention_span__overall_assessment}}
‚Üí Result: Traverses to persona['kid_learning_profile']['attention_span']['overall_assessment']
‚Üí Output: "moderate"

{{PREVIOUS_CONVERSATIONS_MEMORY__0__curiosity_boosters__comment}}
‚Üí Result: Gets first conversation's curiosity boosters comment
```

---

## UI Wireframe Ideas

### Option A: Cascading Dropdowns
```
[Variable: CONVERSATION_MEMORY ‚ñº]
    ‚Üì (on select)
[Top Key: curiosity_boosters ‚ñº]
    ‚Üì (if nested)
[Nested Key: comment ‚ñº]

[Generate Placeholder] ‚Üí {{CONVERSATION_MEMORY__curiosity_boosters__comment}}
```

### Option B: Tree Selector
```
üì¶ CONVERSATION_MEMORY
‚îú‚îÄ üìÇ curiosity_boosters
‚îÇ  ‚îú‚îÄ üìÑ boosters_attempted (array)
‚îÇ  ‚îú‚îÄ üìÑ not_attempted (array)
‚îÇ  ‚îî‚îÄ üìÑ comment (string) [‚úì]
‚îú‚îÄ üìÇ invitation_to_come_back
‚îî‚îÄ üìÇ knowledge_journey

Selected: CONVERSATION_MEMORY__curiosity_boosters__comment
[Copy to Clipboard] [Insert at Cursor]
```

### Option C: Search/Autocomplete
```
Search placeholders: [curioso_____]
                      ‚Üì
  - {{CONVERSATION_MEMORY__curiosity_boosters}}
  - {{CONVERSATION_MEMORY__curiosity_boosters__comment}}
  - {{CONVERSATION_MEMORY__curiosity_boosters__boosters_attempted}}
  - {{USER_PERSONA__curiosity_boosters}}
```

### Option D: Builder Interface
```
Build your placeholder:

Variable Type:     [ CONVERSATION_MEMORY ‚ñº ]
                   [ USER_PERSONA         ]
                   [ PREVIOUS_CONVERSATIONS_MEMORY ]

Available Fields:  ‚òë curiosity_boosters
                   ‚òê invitation_to_come_back
                   ‚òê knowledge_journey
                   ‚òê kid_learning_profile

Sub-fields:        ‚òê boosters_attempted
                   ‚òê not_attempted
                   ‚òë comment

Preview: {{CONVERSATION_MEMORY__curiosity_boosters__comment}}

[Generate]
```

---

## Priority Issues

### Critical (Blocks nested access)
1. ‚ùå `render_memory_snippet()` doesn't traverse nested keys
2. ‚ùå `inject_persona_placeholders()` ignores `requested_keys` entirely
3. ‚ùå `inject_previous_memories_placeholder()` has no key extraction at all

### High (Required for UI)
4. Need schema/mapping file for UI to know available fields
5. Need to handle array access (e.g., `PREVIOUS_CONVERSATIONS_MEMORY__0__...`)

### Medium (Nice to have)
6. Better error messages when invalid keys are requested
7. Type hints in placeholder (e.g., show "string", "object", "array" in UI)
8. Preview of actual data when building placeholder

---

**Last Updated**: Implementation completed
**Files Analyzed**:
- `Brain/src/utils/prompt_injection.py`
- `Brain/src/schemas.py`
- `Brain/src/prompts/memory_generation_prompt.txt`
- `Brain/src/prompts/user_persona_generation_prompt.txt`
- `Brain/src/core/final_response_generator.py`

---

# IMPLEMENTATION COMPLETED ‚úÖ

## Summary of Changes

All nested key access issues have been **FIXED**. The system now fully supports traversing nested JSON structures.

### Files Modified

1. **`Brain/src/utils/prompt_injection.py`** - Core fixes
2. **`Brain/src/utils/prompt_schema_parser.py`** - New parser utility (created)
3. **`Brain/src/utils/placeholder_metadata.json`** - Auto-generated UI metadata (created)

---

## What Was Fixed

### 1. Added Nested Path Traversal (`_get_nested_value`)

**Location**: `prompt_injection.py:64-96`

New helper function that traverses nested dictionaries using key paths:
```python
_get_nested_value({'a': {'b': 'value'}}, ['a', 'b']) ‚Üí 'value'
```

Supports:
- **Nested dicts**: `['curiosity_boosters', 'comment']`
- **Array access**: `['boosters_attempted', '0', 'category']`

---

### 2. Fixed `render_memory_snippet()` ‚úÖ

**Location**: `prompt_injection.py:121-163`

**Before**: Only accessed top-level keys with `memory.get(key)`
**After**: Uses `_get_nested_value()` to traverse nested paths

**Now supports**:
```python
{{CONVERSATION_MEMORY__curiosity_boosters}}  # Top-level object
{{CONVERSATION_MEMORY__curiosity_boosters__comment}}  # Nested string
{{CONVERSATION_MEMORY__kid_learning_profile__attention_span__assessment}}  # 3 levels deep
```

---

### 3. Fixed `render_persona_snippet()` ‚úÖ

**Location**: `prompt_injection.py:206-248`

**Same fix** as memory snippet - now traverses nested paths.

**Now supports**:
```python
{{USER_PERSONA__curiosity_boosters}}
{{USER_PERSONA__kid_learning_profile__attention_span__overall_assessment}}
```

---

### 4. Fixed `inject_persona_placeholders()` ‚úÖ

**Location**: `prompt_injection.py:251-297`

**Before**: Ignored `requested_keys` completely, always did full JSON dump
**After**: Checks if keys were requested and uses selective rendering

**Now supports TWO modes**:
1. **Full injection**: `{{USER_PERSONA}}` ‚Üí Complete JSON dump
2. **Selective**: `{{USER_PERSONA__curiosity_boosters}}` ‚Üí Only that field

---

### 5. Completely Rewrote Previous Memories Injection ‚úÖ

**Location**: `prompt_injection.py:301-427`

**Added**:
- `extract_previous_memory_placeholders()` (line 301-320)
- `render_previous_memories_snippet()` (line 323-380)
- Rewrote `inject_previous_memories_placeholder()` (line 383-427)

**Now supports FOUR modes**:

| Pattern | Example | Result |
|---------|---------|--------|
| Full dump | `{{PREVIOUS_CONVERSATIONS_MEMORY}}` | All memories as JSON |
| Specific conversation | `{{PREVIOUS_CONVERSATIONS_MEMORY__0}}` | First conversation memory |
| Field from specific | `{{PREVIOUS_CONVERSATIONS_MEMORY__0__curiosity_boosters}}` | Field from conv #1 |
| Field from ALL | `{{PREVIOUS_CONVERSATIONS_MEMORY__curiosity_boosters}}` | Field from all convs |

**Array handling**:
- Index can be any number: `__0__`, `__1__`, `__2__`, etc.
- Out-of-range returns helpful error: `[Conversation index 5 out of range (have 3 conversations)]`

---

## Prompt Schema Parser (NEW) üÜï

**File**: `Brain/src/utils/prompt_schema_parser.py`

Automatically extracts JSON schemas from prompt files by parsing the example JSON in the prompts.

### Features

1. **Parses JSON from prompts** - Handles:
   - Code blocks (` ``` `)
   - Template syntax (`{{` ‚Üí `{`)
   - Invalid JSON patterns (`true/false` ‚Üí `true`)

2. **Builds nested schema tree** - Tracks:
   - Field types (string, number, boolean, array, object)
   - Nested structure (full paths like `curiosity_boosters__comment`)
   - Array item types

3. **Generates UI-friendly field list** - For each field:
   ```json
   {
     "path": "kid_learning_profile__attention_span__assessment",
     "type": "string",
     "label": "kid_learning_profile ‚Üí attention_span ‚Üí assessment"
   }
   ```

### Hardcoded Mapping

```python
VARIABLE_TO_PROMPT_MAPPING = {
    "CONVERSATION_MEMORY": "Brain/src/prompts/memory_generation_prompt.txt",
    "USER_PERSONA": "Brain/src/prompts/user_persona_generation_prompt.txt",
    "PREVIOUS_CONVERSATIONS_MEMORY": "Brain/src/prompts/memory_generation_prompt.txt"
}
```

**To update**: If you change a prompt file's JSON structure, just run:
```bash
python Brain/src/utils/prompt_schema_parser.py
```

This regenerates `placeholder_metadata.json` automatically.

---

## Generated Metadata File üìÑ

**File**: `Brain/src/utils/placeholder_metadata.json`

Complete metadata for all 3 placeholder types:

### CONVERSATION_MEMORY
- **39 fields** parsed from `memory_generation_prompt.txt`
- Includes all nested paths like:
  - `curiosity_boosters__boosters_attempted__0__category`
  - `kid_learning_profile__attention_span__assessment`
  - `knowledge_journey__missing_for_holistic_picture__topic_1`

### USER_PERSONA
- **Same 4 top-level keys** as CONVERSATION_MEMORY
- Parsed from `user_persona_generation_prompt.txt`
- Only shows `curiosity_boosters` subfields in example (incomplete prompt JSON)

### PREVIOUS_CONVERSATIONS_MEMORY
- **Same 39 fields** as CONVERSATION_MEMORY (same source prompt)
- **Special flags**:
  - `"is_array": true`
  - `"requires_runtime_index": true`
  - `"usage_patterns": [...]` - Shows 4 different usage modes

---

## UI Implementation Notes

### For Cascading Dropdowns

The `placeholder_metadata.json` provides everything needed:

```javascript
// Pseudo-code for UI
const metadata = require('./placeholder_metadata.json');

// Step 1: Dropdown for variable type
const variables = Object.keys(metadata); // ['CONVERSATION_MEMORY', 'USER_PERSONA', ...]

// Step 2: Dropdown for fields (after user selects variable)
const selectedVar = 'CONVERSATION_MEMORY';
const fields = metadata[selectedVar].fields; // Array of {path, type, label}

// Filter top-level only for first dropdown
const topLevelFields = fields.filter(f => !f.path.includes('__'));

// Step 3: Show nested fields when parent is selected
const selectedField = 'curiosity_boosters';
const nestedFields = fields.filter(f =>
  f.path.startsWith(selectedField + '__') &&
  f.path.split('__').length === 2  // Only direct children
);

// Step 4: Build placeholder string
const placeholder = `{{${selectedVar}__${selectedPath}}}`;
```

### Partial String Display ‚úÖ

You're right - showing the partial placeholder as user selects is better UX:

```
User selects: CONVERSATION_MEMORY
  ‚Üí Display: {{CONVERSATION_MEMORY_____}}  (shows it's incomplete)

User selects: curiosity_boosters
  ‚Üí Display: {{CONVERSATION_MEMORY__curiosity_boosters}}  (can use this!)

User continues: comment
  ‚Üí Display: {{CONVERSATION_MEMORY__curiosity_boosters__comment}}
```

**Implementation tip**:
- After each dropdown selection, update a text input/preview area
- Allow user to click "Use This" at any level
- No need to force them to go to leaf nodes

### Special Handling for PREVIOUS_CONVERSATIONS_MEMORY

Since array length is unknown at design-time:

**Option A**: Text input for index
```
[ Variable: PREVIOUS_CONVERSATIONS_MEMORY ‚ñº ]
[ Index: [___] ] (text input, accepts numbers)
[ Field: curiosity_boosters ‚ñº ]

Preview: {{PREVIOUS_CONVERSATIONS_MEMORY__2__curiosity_boosters}}
```

**Option B**: Show usage pattern selector
```
[ Variable: PREVIOUS_CONVERSATIONS_MEMORY ‚ñº ]

Usage mode:
  ‚óã Full dump of all conversations
  ‚óã Specific conversation by index: [0]
  ‚óã Field from specific conversation: Index [0] Field [curiosity_boosters ‚ñº]
  ‚óè Field from ALL conversations: [curiosity_boosters ‚ñº]

Preview: {{PREVIOUS_CONVERSATIONS_MEMORY__curiosity_boosters}}
```

Check `metadata['PREVIOUS_CONVERSATIONS_MEMORY']['usage_patterns']` for the 4 modes.

---

## Testing the Implementation

### Test nested access for CONVERSATION_MEMORY

Create a test prompt file with:
```
Test prompt: {{CONVERSATION_MEMORY__curiosity_boosters__comment}}
```

Expected: Extracts just the `comment` string from `curiosity_boosters` object.

### Test nested access for USER_PERSONA

```
Test prompt: {{USER_PERSONA__kid_learning_profile__attention_span__overall_assessment}}
```

Expected: Extracts just the assessment value (e.g., "moderate")

### Test array access for PREVIOUS_CONVERSATIONS_MEMORY

```
Test 1: {{PREVIOUS_CONVERSATIONS_MEMORY__0__curiosity_boosters__comment}}
Expected: Comment from first conversation

Test 2: {{PREVIOUS_CONVERSATIONS_MEMORY__curiosity_boosters}}
Expected: All comments from all conversations formatted as list

Test 3: {{PREVIOUS_CONVERSATIONS_MEMORY__99__curiosity_boosters}}
Expected: "[Conversation index 99 out of range (have X conversations)]"
```

---

## Maintenance

### When Prompt JSON Structure Changes

1. Update the prompt file (e.g., `memory_generation_prompt.txt`)
2. Run: `python Brain/src/utils/prompt_schema_parser.py`
3. Check generated `placeholder_metadata.json`
4. UI will automatically reflect new fields (if using dynamic metadata)

### When Adding New Placeholder Variables

1. Add entry to `VARIABLE_TO_PROMPT_MAPPING` in `prompt_schema_parser.py`
2. Add regex pattern in `prompt_injection.py` (follow existing patterns)
3. Add extraction and injection functions
4. Re-run parser to generate metadata
5. Update UI to show new variable in dropdown

---

## Current Status Table (UPDATED)

| Placeholder Type | Nested Key Support | Array Access | Selective Injection | Auto-parsed | Status |
|-----------------|-------------------|--------------|-------------------|-------------|---------|
| `{{CONVERSATION_MEMORY}}` | ‚úÖ YES | N/A | ‚úÖ YES | ‚úÖ YES | **COMPLETE** |
| `{{USER_PERSONA}}` | ‚úÖ YES | N/A | ‚úÖ YES | ‚úÖ YES | **COMPLETE** |
| `{{PREVIOUS_CONVERSATIONS_MEMORY}}` | ‚úÖ YES | ‚úÖ YES (0-indexed) | ‚úÖ YES | ‚úÖ YES | **COMPLETE** |

---

## Examples of Valid Placeholders

### CONVERSATION_MEMORY
```
{{CONVERSATION_MEMORY}}  # Full dump
{{CONVERSATION_MEMORY__curiosity_boosters}}  # Top-level object
{{CONVERSATION_MEMORY__curiosity_boosters__comment}}  # Nested string
{{CONVERSATION_MEMORY__curiosity_boosters__boosters_attempted}}  # Array
{{CONVERSATION_MEMORY__kid_learning_profile__attention_span__assessment}}  # 3 levels deep
{{CONVERSATION_MEMORY__knowledge_journey__initial_knowledge__topic_1}}  # Dynamic key
```

### USER_PERSONA
```
{{USER_PERSONA}}  # Full dump
{{USER_PERSONA__curiosity_boosters__most_effective}}  # Array of objects
{{USER_PERSONA__invitation_to_come_back__preferred_endings}}  # String
{{USER_PERSONA__kid_learning_profile__engagement_patterns__dominant_style}}  # Deep nested
```

### PREVIOUS_CONVERSATIONS_MEMORY
```
{{PREVIOUS_CONVERSATIONS_MEMORY}}  # All conversations full dump
{{PREVIOUS_CONVERSATIONS_MEMORY__0}}  # First conversation full dump
{{PREVIOUS_CONVERSATIONS_MEMORY__1__curiosity_boosters}}  # Second conv's curiosity_boosters
{{PREVIOUS_CONVERSATIONS_MEMORY__0__kid_learning_profile__attention_span__assessment}}  # Deep nested from first conv
{{PREVIOUS_CONVERSATIONS_MEMORY__curiosity_boosters__comment}}  # Comment from ALL conversations
```

---

**All implementation complete! Ready for UI integration.**

---

# Backend API & Frontend Component ‚úÖ

## Backend API Endpoint

**Endpoint**: `GET /api/prompts/{prompt_id_or_name}/placeholder-metadata`

**Location**: `backend/src/prompts/router.py:287`

**Purpose**: Dynamically parses a prompt's text to extract available placeholder fields.

**Request Example**:
```bash
curl http://localhost:5000/api/prompts/memory_generation_prompt/placeholder-metadata
```

**Response Example**:
```json
{
  "prompt_name": "memory_generation_prompt",
  "prompt_id": 1,
  "variables": {
    "CONVERSATION_MEMORY": {
      "variable_name": "CONVERSATION_MEMORY",
      "description": "Memory data from the current conversation",
      "is_array": false,
      "fields": [
        {"path": "curiosity_boosters", "type": "object", "label": "curiosity_boosters"},
        {"path": "curiosity_boosters__comment", "type": "string", "label": "curiosity_boosters ‚Üí comment"},
        ...
      ]
    },
    "PREVIOUS_CONVERSATIONS_MEMORY": {
      "variable_name": "PREVIOUS_CONVERSATIONS_MEMORY",
      "is_array": true,
      "requires_runtime_index": true,
      "usage_patterns": [...]
    }
  }
}
```

**How It Works**:
1. Fetches the active prompt version from database
2. Extracts JSON example from prompt text (from ``` code blocks)
3. Parses JSON structure recursively
4. Returns flat list of all available field paths

**No Manual Updates Needed**: When you edit a prompt in the UI and change its JSON structure, the metadata updates automatically on next request!

---

## React Component

**File**: `curiosity-coach-frontend/src/components/PlaceholderSelector.tsx`

**Features**:
- ‚úÖ Cascading dropdowns (variable ‚Üí field ‚Üí nested field)
- ‚úÖ Live preview of placeholder string as user selects
- ‚úÖ "Use This" button to insert placeholder at any level
- ‚úÖ Special handling for array variables (index input)
- ‚úÖ Shows usage patterns for complex variables
- ‚úÖ Responsive error handling

**Usage Example**:
```tsx
import { PlaceholderSelector } from './components/PlaceholderSelector';

function PromptEditor() {
  const [promptText, setPromptText] = useState('');

  const handlePlaceholderSelect = (placeholder: string) => {
    // Insert placeholder at cursor position or append
    setPromptText(prev => prev + placeholder);
  };

  return (
    <div>
      <textarea value={promptText} onChange={e => setPromptText(e.target.value)} />

      <PlaceholderSelector
        promptId="memory_generation_prompt"  // or numeric ID
        onPlaceholderSelect={handlePlaceholderSelect}
        className="mt-4"
      />
    </div>
  );
}
```

**Component Props**:
```typescript
interface PlaceholderSelectorProps {
  promptId: string | number;           // Prompt ID or name
  onPlaceholderSelect: (placeholder: string) => void;  // Callback when user clicks "Use This"
  className?: string;                   // Optional CSS classes
}
```

**User Flow**:
1. User selects variable (e.g., `CONVERSATION_MEMORY`)
2. Preview shows: `{{CONVERSATION_MEMORY}}`
3. User selects field (e.g., `curiosity_boosters`)
4. Preview updates: `{{CONVERSATION_MEMORY__curiosity_boosters}}`
5. User can:
   - Click "Use This" to insert current placeholder
   - Continue drilling down into nested fields
   - Click "Back" to go up one level
   - Click "Reset" to start over

**Special Handling for `PREVIOUS_CONVERSATIONS_MEMORY`**:
- Shows optional index input field
- If user enters "0", preview shows: `{{PREVIOUS_CONVERSATIONS_MEMORY__0__field_name}}`
- If user leaves empty, preview shows: `{{PREVIOUS_CONVERSATIONS_MEMORY__field_name}}` (gets field from ALL conversations)
- Displays usage patterns panel with examples

---

## Integration Checklist

- [x] Backend parser utility created (`backend/src/prompts/placeholder_parser.py`)
- [x] API endpoint added (`GET /api/prompts/{id}/placeholder-metadata`)
- [x] Parser tested with real prompt examples
- [x] React component created (`PlaceholderSelector.tsx`)
- [ ] Component integrated into prompt editor UI
- [ ] Environment variable `REACT_APP_API_URL` configured
- [ ] Tested with real database prompts
- [ ] UI styling adjusted to match design system

---

## Testing Locally

### 1. Test Backend Parser
```bash
cd backend
python test_placeholder_parser.py
```

Expected output: JSON with parsed fields from test prompt.

### 2. Test API Endpoint

Start backend:
```bash
cd backend
python -m uvicorn src.main:app --reload --port 5000
```

Test endpoint (replace with real prompt name):
```bash
curl http://localhost:5000/api/prompts/memory_generation_prompt/placeholder-metadata | jq
```

### 3. Test Frontend Component

1. Add component to your prompt editor
2. Open browser dev tools ‚Üí Network tab
3. Select a prompt
4. Verify API call is made and returns metadata
5. Test dropdown interactions
6. Verify "Use This" button inserts correct placeholder

---

## Next Steps (For Frontend Integration)

1. **Add to Prompt Editor Page**:
   - Import `PlaceholderSelector`
   - Position it near the prompt text editor
   - Wire up `onPlaceholderSelect` to insert placeholder at cursor

2. **Cursor Position Insertion** (Optional Enhancement):
   ```typescript
   const insertAtCursor = (textarea: HTMLTextAreaElement, placeholder: string) => {
     const start = textarea.selectionStart;
     const end = textarea.selectionEnd;
     const text = textarea.value;
     const newText = text.substring(0, start) + placeholder + text.substring(end);
     textarea.value = newText;
     textarea.selectionStart = textarea.selectionEnd = start + placeholder.length;
   };
   ```

3. **Styling**:
   - Component uses Tailwind classes
   - Customize colors/spacing to match your design system
   - Consider adding a tooltip/help icon explaining placeholders

4. **Error Handling**:
   - Component shows error if prompt has no JSON
   - Consider adding a "Learn More" link to documentation

---

**Implementation Complete! üéâ**

All the wiring is done. Just integrate the component into your prompt editor UI and it will work automatically with any prompt that has a JSON example.
