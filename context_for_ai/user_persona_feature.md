# User Persona Feature

This document outlines the requirements, proposed plan, and implementation steps for the User Persona feature.

## 1. Feature Requirement

The goal of the User Persona feature is to create and maintain a "persona" for each user based on their interactions with the Curiosity Coach. This persona will be a structured JSON object that summarizes the user's interests, learning style, and other relevant characteristics as inferred from their conversation histories.

### Key Requirements:

*   **Persona Storage:** A new database table, `user_persona`, will be created to store the persona for each user.
    *   It will have a unique foreign key to the `users` table.
    *   It will contain a JSONB field to store the persona data.
*   **Persona Generation:** The persona will be generated by an LLM.
    *   The input for the LLM will be all of the user's `conversation_memories`.
    *   A new system prompt will be created to guide the LLM in extracting a persona from the memories.
    *   The initial output from the LLM should be a simple JSON object, like `{"persona": "The user is curious about physics and prefers learning through analogies."}`.
*   **Triggering Generation:** The persona generation process should be triggerable in two ways, similar to the existing conversation memory generation:
    1.  **On-Demand:** An API endpoint to trigger persona generation for a specific user.
    2.  **Batch Process:** A mechanism to automatically generate or update personas for multiple users in a batch (e.g., for all users with new conversation memories since the last persona update).

## 2. Proposed Plan

This feature will be integrated into the existing `backend` and `Brain` services. The process will be asynchronous, using the existing SQS queue to decouple the API from the LLM processing.

### High-Level Flow

1.  A trigger (either a direct API call or a scheduled task) invokes a new endpoint on the **Backend** service (e.g., `/api/tasks/trigger-user-persona-generation`).
2.  The **Backend** identifies the target user(s) and sends a `user_persona_generation` task message to the SQS queue for each user.
3.  The **Brain** lambda is triggered by the SQS message.
4.  The **Brain** service fetches all `conversation_memories` for the specified user from the **Backend**.
5.  It uses a new "persona generation" prompt and the user's memories to call an LLM and generate the persona JSON.
6.  The **Brain** validates the LLM's response.
7.  The **Brain** sends the generated persona to a new endpoint on the **Backend** (e.g., `/api/user-personas/`).
8.  The **Backend** saves the persona data to the `user_persona` table.

### Architectural Changes

*   **Backend:**
    *   **Database:** A new `UserPersona` model and an associated Alembic migration.
    *   **API:**
        *   New schemas, CRUD operations, and a router for `UserPersona`.
        *   An endpoint to create/update a user persona (for the Brain).
        *   A new task-triggering endpoint.
*   **Brain:**
    *   A new prompt file for persona generation.
    *   New logic to handle the `user_persona_generation` task from both SQS and direct HTTP requests. This will involve fetching data, calling the LLM in "JSON mode" for reliable output, and posting the result back to the Backend.

## 3. Detailed Implementation Steps

### Backend (`backend/`)

-   [x] **Database (models.py & alembic)**
    -   [x] Add `UserPersona` model to `src/models.py`. It should include `id`, `user_id` (unique FK to `users.id`), and `persona_data` (JSONB). Ensure relationships are set up correctly.
    -   [x] Generate a new Alembic migration script (`alembic revision -m "create_user_persona_table" --autogenerate`).
    -   [x] Review and apply the migration (`alembic upgrade head`).
-   [x] **API for User Persona (`src/user_personas/`)**
    -   [x] Create a new directory `src/user_personas/`.
    -   [x] Create `src/user_personas/schemas.py` with `UserPersonaCreate` and `UserPersona` Pydantic models.
    -   [x] Create `src/user_personas/crud.py` with `create_or_update_user_persona` function. This should update the persona if one already exists for the user.
    -   [x] Create `src/user_personas/router.py` with a `POST /` endpoint that accepts persona data and saves it using the CRUD function. This endpoint will be called by the Brain.
    -   [x] Mount the new router in `src/main.py` under the `/api/user-personas` prefix.
-   [x] **Internal API for Brain (`src/internal/`)**
    -   [x] Create `src/internal/router.py` with a `GET /users/{user_id}/memories` endpoint.
    -   [x] This internal endpoint allows the Brain service to securely fetch all conversation memories for a specific user without public exposure.
    -   [x] Implement the corresponding `crud` function to support this endpoint.
    -   [x] Mount this internal router in `src/main.py`.
    -   [x] Add a `GET /users/{user_id}/persona` endpoint to the internal router to allow the Brain to fetch a user's persona.
-   [x] **Task Triggering API (`src/tasks/router.py`)**
    -   [x] Add a new asynchronous endpoint `POST /trigger-user-persona-generation`.
    -   [x] Add a new synchronous endpoint `POST /trigger-user-persona-generation-sync` for on-demand, immediate processing, which is useful for testing and administration. This endpoint awaits the completion of the task.
    -   [x] Both endpoints should accept an optional `user_id`.
    -   [x] If `user_id` is provided, enqueue a persona generation task for that user.
    -   [x] If `user_id` is not provided, implement logic to find all users who have new conversation memories since their last persona update and enqueue tasks for them. The logic will be as follows:
        1.  Find all users who have a `user_persona` record. For each of these users, check if there are any `conversation_memories` with a `created_at` timestamp that is more recent than the `user_persona.updated_at` timestamp.
        2.  Find all users who have `conversation_memories` but do *not* have a `user_persona` record.
        3.  Compile a unique list of user IDs from both steps and enqueue a `user_persona_generation` task for each.
    -   [x] Update `src/queue/service.py` to include a function for sending `user_persona_generation` tasks to SQS.

### Brain (`Brain/`)

-   [x] **Prompt (`prompts/`)**
    -   [x] Create `prompts/user_persona_generation_prompt.txt`. This prompt will instruct the LLM to analyze a collection of conversation summaries and strictly output only a JSON object describing the user's persona.
-   [x] **Core Logic (`src/core/`)**
    -   [x] Create a new file `src/core/user_persona_generator.py`.
    -   [x] Implement a function `generate_persona_for_user(user_id)`.
    -   [x] This function will:
        -   [x] Call the backend API to fetch all `conversation_memories` for the given `user_id` via the new internal endpoint.
        -   [x] Load the persona generation prompt.
        -   [x] Format the memories and the prompt for the LLM.
        -   [x] Use `src/services/llm_service.py` to get the persona JSON from the LLM, enforcing a JSON response by using the model's "JSON mode".
        -   [x] Use `src/services/api_service.py` to call the backend's `/api/user-personas/` endpoint to save the persona.
-   [x] **Task Handling (`src/lambda_function.py` and `src/main.py`)**
    -   [x] Modify the Brain's entrypoints to handle persona generation tasks arriving from both SQS and direct HTTP calls to the `/tasks` endpoint.
    -   [x] Add logic to identify `user_persona_generation` task types from the incoming SQS message or HTTP request body.
    -   [x] When a persona generation task is received, call the `generate_persona_for_user` function from the new `user_persona_generator.py` module.
    -   [x] Update `src/main.py` to fetch the user's persona when processing an incoming message.
-   [x] **Services (`src/services/api_service.py`)**
    -   [x] Add a function to fetch conversation memories for a user by calling the backend's `/api/internal/users/{user_id}/memories` endpoint.
    -   [x] Add a function to post the generated user persona to the backend.
    -   [x] Add a function to get the user persona for a specific user.

### Testing (`tests/`)

-   [x] **Test File Setup**
    -   [x] Create a new test file `tests/test_e2e_user_persona.py`.
-   [x] **Backend API Tests**
    -   [x] Write a test for the `POST /api/user-personas/` endpoint to ensure it correctly creates and updates a user persona (requires authentication).
    -   [x] Write a test for the asynchronous task trigger: `POST /api/tasks/trigger-user-persona-generation` with a specific `user_id`. Verify that a task is enqueued.
    -   [x] Write a test for the synchronous task trigger: `POST /api/tasks/trigger-user-persona-generation-sync`. Verify that the task completes and the persona is created.
    -   [x] Write a test for the batch task trigger: `POST /api/tasks/trigger-user-persona-generation` without a `user_id`. Verify that the correct users are identified for persona generation.
-   [ ] **End-to-End Flow Test**
    -   [ ] Write an E2E test that simulates the full persona generation flow:
        -   [ ] 1. Create a user, conversations, and mock `conversation_memories`.
        -   [ ] 2. Call the synchronous persona generation endpoint.
        -   [ ] 3. Verify that the Brain service correctly processes the task and calls the backend to save the result.
        -   [ ] 4. Verify that the `user_persona` is successfully created in the database with the correct data. 

## 4. Persona Usage in Conversation

In addition to generating personas, the system now actively uses them to tailor the conversation.

1.  When the **Brain** service receives a message to process, it first calls the **Backend** to fetch the user's persona via the new `/api/internal/users/{user_id}/persona` endpoint.
2.  This persona data is then passed through the processing pipeline.
3.  The core prompt-formatting logic in `src/process_query_entrypoint.py` checks if a special placeholder, `{{USER_PERSONA}}`, exists in the prompt template being used.
4.  If the placeholder is found, it is replaced with:
    -   The user's persona, formatted as a JSON string, if a persona exists.
    -   A default message, "User persona not available," if no persona exists for the user.
5.  This allows for dynamic, real-time personalization of the AI's responses based on the user's learned interests and style. 