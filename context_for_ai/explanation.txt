# Technical Explanation

This document provides a technical overview of the Curiosity Coach project.

## Project Overview

The Curiosity Coach project is a conversational AI application designed to help students learn by fostering curiosity. It consists of a frontend, a backend, and a "Brain" service.

## Architecture

The project follows a microservices architecture, with three main components:

1.  **Frontend:** A React application that provides the user interface for the chat.
2.  **Backend:** A FastAPI application that handles user authentication, conversation management, and acts as a gateway to the Brain service.
3.  **Brain:** A Python service that is responsible for processing user messages and generating responses.

The services are deployed on AWS using Terraform.

## Services

### 1. Frontend

*   **Technology:** React, TypeScript, Tailwind CSS
*   **Functionality:**
    *   User login
    *   Chat interface for conversations with the AI
    *   Interface for testing different prompts
    *   Interface for viewing different versions of prompts
*   **Infrastructure:**
    *   Hosted on an S3 bucket
    *   Served by a CloudFront distribution
    *   DNS managed by Cloudflare

### 2. Backend

*   **Technology:** Python, FastAPI, PostgreSQL, SQLAlchemy
*   **Functionality:**
    *   User authentication (phone number based)
    *   CRUD operations for users, conversations, messages, prompts, prompt versions, and memories
    *   An endpoint (`/api/tasks/trigger-memory-generation`) to initiate memory generation for recently ended conversations.
    *   Forwards user messages to the Brain service via an SQS queue and enqueues batch tasks for memory generation
    *   Receives responses from the Brain service via an HTTP callback
*   **Infrastructure:**
    *   Runs as a Docker container on AWS Lambda
    *   Exposed via a Lambda Function URL
    *   Uses an RDS for PostgreSQL database
    *   Uses an SQS queue to communicate with the Brain service

### 3. Brain

*   **Technology:** Python, FastAPI
*   **Functionality:**
    *   Processes user messages to generate intelligent responses.
    *   Handles asynchronous batch jobs from SQS, such as generating structured memories from conversation histories.
    *   Uses a configurable pipeline of steps to process messages:
        *   **Intent Gathering:** Determines the user's intent (e.g., educational, conversational).
        *   **Knowledge Retrieval:** Retrieves relevant information for educational queries.
        *   **Response Generation:** Generates a response based on the intent and retrieved knowledge.
        *   **Learning Enhancement:** Adds elements to the response to foster curiosity, like analogies or thought-provoking questions.
    *   The pipeline can be configured dynamically via a `FlowConfig` file stored in S3. The memory generation process uses an LLM to summarize conversations.
    *   Communicates with the backend to get conversation history and send back responses.
*   **Infrastructure:**
    *   Runs as a Docker container on AWS Lambda
    *   Triggered by messages from the SQS queue from the backend
    *   Can also be invoked via a Lambda Function URL for testing and configuration
    *   Stores its configuration in an S3 bucket

## Database Schema

The backend uses a PostgreSQL database with the following tables:

*   `users`: Stores user information (phone number).
*   `conversations`: Stores conversation metadata (user, title, etc.).
*   `conversation_memories`: Stores structured summaries of conversations, generated by the Brain.
*   `messages`: Stores the messages in each conversation.
*   `message_pipeline_data`: Stores additional data about the message processing pipeline from the Brain service.
*   `prompts`: Stores different types of prompts used by the Brain service.
*   `prompt_versions`: Stores different versions of each prompt.

## Tech Stack Summary

*   **Frontend:** React, TypeScript, Tailwind CSS
*   **Backend:** Python, FastAPI, PostgreSQL, SQLAlchemy
*   **Brain:** Python, FastAPI
*   **Infrastructure:** AWS (Lambda, S3, RDS, SQS, CloudFront, ECR), Terraform, Docker
*   **CI/CD:** GitHub Actions (not explicitly seen, but assumed for a project of this nature)

### Database Schema Diagram

```mermaid
erDiagram
    users {
        int id PK
        string phone_number "unique"
        datetime created_at
    }

    conversations {
        int id PK
        int user_id FK
        string title
        int prompt_version_id FK
        datetime created_at
        datetime updated_at
    }

    conversation_memories {
        int id PK
        int conversation_id FK "unique"
        json memory_data
        datetime created_at
        datetime updated_at
    }

    messages {
        int id PK
        int conversation_id FK
        string content
        bool is_user
        datetime timestamp
        int responds_to_message_id FK
    }

    message_pipeline_data {
        int id PK
        int message_id FK "unique"
        json pipeline_data
        datetime created_at
    }

    prompts {
        int id PK
        string name "unique"
        string description
        datetime created_at
        datetime updated_at
    }

    prompt_versions {
        int id PK
        int prompt_id FK
        int user_id FK
        int version_number
        string prompt_text
        bool is_active
        bool is_production
        datetime created_at
    }

    users ||--o{ conversations : "has"
    users ||--o{ prompt_versions : "authors"
    conversations ||--o{ messages : "contains"
    conversations }o--|| prompt_versions : "uses"
    conversations |o--|| conversation_memories : "has one"
    messages ||--|{ message_pipeline_data : "has"
    messages }o--o| messages : "responds to"
    prompts ||--o{ prompt_versions : "has versions"
}
```

This concludes the technical explanation of the Curiosity Coach project.

---

# Non-Technical Product Overview

This document provides a non-technical overview of the Curiosity Coach project, intended for a product manager or other non-technical stakeholders.

## Product Vision

The Curiosity Coach is an AI-powered learning companion that helps students explore their interests and develop critical thinking skills. Instead of just providing answers, the Curiosity Coach engages students in a conversation, asks thought-provoking questions, and encourages them to think for themselves.

### User Flow Diagram

```mermaid
graph TD
    A["User Logs In"] --> B{"Start new or continue?"};
    B -- "Start New" --> C["Starts New Conversation"];
    B -- "Continue" --> D["Selects Existing Conversation"];
    C --> E["Asks a Question"];
    D --> E;
    E --> F["Backend sends to Brain"];
    F --> G["Brain generates guiding question/response"];
    G --> H["Backend sends response to Frontend"];
    H --> I["User sees Coach's response"];
    I --> J{"Engages in Dialogue"};
    J -- "Responds" --> E;
    J -- "Ends Convo" --> K["Conversation is Saved"];
    subgraph "Review"
        L["User can review past conversations at any time"]
    end
    A --> L;
    K --> L;
```

## User Flow

The primary user flow is a conversation with the Curiosity Coach. Here's a typical scenario:

1.  **Login:** A student logs in to the application using their phone number.
2.  **Start a Conversation:** The student starts a new conversation or continues an existing one.
3.  **Ask a Question:** The student asks a question about a topic they are interested in.
4.  **Engage in a Dialogue:** The Curiosity Coach responds not with a direct answer, but with a question or a prompt to encourage the student to think more deeply about the topic. For example, if a student asks "Why is the sky blue?", the coach might respond with "That's a great question! What do you think makes the sky blue?".
5.  **Explore and Learn:** The conversation continues in this manner, with the coach guiding the student to discover the answer for themselves. The coach might provide analogies, examples, or break down complex topics into smaller pieces.
6.  **Conversation History:** All conversations are saved, so the student can review them later.

## Key Features

*   **Conversational Learning:** The core of the product is the conversational interface that promotes active learning.
*   **Personalized Experience:** The coach can adapt to the student's level of understanding and interests.
*   **Conversation Memory:** The system can summarize completed conversations to build a structured memory. This provides valuable insights into the student's learning journey and can be used to personalize future interactions.
*   **Prompt Engineering:** The system uses a sophisticated prompt engineering system to generate high-quality, engaging responses. The prompts can be easily updated and versioned to improve the coach's performance.
*   **Configurable "Brain":** The "Brain" of the coach is highly configurable. We can change its behavior by adjusting a `FlowConfig` file, allowing us to experiment with different conversational strategies without changing the code.

## Database Schema (Simplified)

The application stores data about:

*   **Users:** Who is using the application.
*   **Conversations:** The conversations each user has had.
*   **Messages:** The individual messages within each conversation.
*   **Memories:** Summaries of past conversations to provide long-term context.
*   **Prompts:** The templates used to generate the coach's responses.

This data helps us understand how users are interacting with the product and how we can improve it.

## How the Pieces Connect

1.  A student sends a message from the **Frontend** (the React app).
2.  The **Backend** (the FastAPI app) receives the message, saves it to the database, and sends it to the **Brain** service.
3.  The **Brain** service processes the message, using its prompts and configuration to decide on the best response.
4.  The **Brain** sends the response back to the **Backend**.
5.  The **Backend** saves the response to the database and sends it to the **Frontend**.
6.  The **Frontend** displays the response to the student.

This cycle continues for the entire conversation.

### Component Connection Diagram (Chat)

```mermaid
graph TD
    subgraph "User's Browser"
        User
    end

    subgraph "AWS Cloud"
        CloudFront
        S3_Frontend["S3 for Frontend"]
        Lambda_Backend["Backend Lambda (FastAPI)"]
        RDS["RDS (PostgreSQL)"]
        SQS["SQS Queue"]
        Lambda_Brain["Brain Lambda (Python)"]
        S3_Brain_Config["S3 for Brain Config"]
    end

    User -- "HTTPS Request" --> CloudFront;
    CloudFront -- "Serves React App" --> S3_Frontend;
    User -- "API Calls (Login, Chat)" --> Lambda_Backend;
    Lambda_Backend -- "CRUD Operations" --> RDS;
    Lambda_Backend -- "Enqueues Message" --> SQS;
    SQS -- "Triggers" --> Lambda_Brain;
    Lambda_Brain -- "Reads FlowConfig" --> S3_Brain_Config;
    Lambda_Brain -- "Posts Response" --> Lambda_Backend;
    Lambda_Backend -- "Sends response to User" --> User;
```

### Component Connection Diagram (Memory Generation)

In addition to the real-time chat flow, there is an asynchronous, manually-triggered process to create memories from conversations.

```mermaid
graph TD
    subgraph "Manual Trigger"
        A["Developer calls API endpoint"]
    end

    subgraph "Backend"
        B["Finds inactive conversations"]
        C["Sends list to SQS"]
    end

    subgraph "Brain"
        D["Picks up task from SQS"]
        E["Reads conversation history"]
        F["Generates summary (memory) with LLM"]
        G["Saves memory to database via Backend"]
    end
    
    A --> B;
    B --> C;
    C --> D;
    D --> E;
    E --> F;
    F --> G;
```

This overview should provide a good understanding of the Curiosity Coach project from a product perspective. 